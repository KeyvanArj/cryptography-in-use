# Secrecy

`Secrecy` is a means of preventing an unauthorized observer of a message from determining its contents.
`Shared secret` is a value that is known to two parties. The secret can be as simple as a password, 
                or it can be an encryption key both parties know.

Encryption provides `secrecy` for a tranferred message. In most situations we decide to use a `shared secret key` in a `symmetric-key` encryption algorithm 
to provide cipher messages. And sometimes, e.g. to transfer the `shared secret key` in `key exchange` process, 
the best solution is to use an `asymmetric-key` encryption algorithm  .

In all of these situations we need to generate secret keys (symmetric/asymmetric) and **store** them safely.
One of the most secure approaches to generate secret keys is to use a `secret` which just client know it or just belongs to her uniquely, e.g. password or naional id. 
This `secret` is called a seed, and the algorithm used to derive multiple secret keys from this seed is called a `Key Derivation Function` (KDF).

## Key Derivation

[PBKDF2](https://www.ietf.org/rfc/rfc2898.txt) applies a pseudorandom function, such as hash-based message authentication code (HMAC), to the input password or passphrase along with a salt value and repeats the process many times to produce a derived key, which can then be used as a cryptographic key in subsequent operations. The added computational work makes password cracking much more difficult, and is known as key stretching.

Assume that the client's password is `123456`, and you would like to generate a 
secret key for `AES` encryption algorithm in `CBC` mode. So, beside the secret key you need an `initial vector`.
PBKDF2 also uses a `Salt` to generate a secret key from the passowrd. 
The following OpenSSL command can be used to derivate a secret while have set the salt manually.:

```
$  openssl enc -aes-256-cbc -pbkdf2 -md sha1 -pass pass:123456 -P -S 05775a1c0bafcade -iter 1000
```

## Key Storage

## PDF Encryption

To encrypt a pdf file you need to generate a `Secret Key` and an `Initial Vector`.

Key is generated by the following command, The size of AES-256 key is 256 bits, So it's a random 32 bytes array : 
 
 ```
 $ openssl rand -base64 32
   QNV2GQxfFWXwmZTWmoJrSxYNLmqTUxv9g5NeQpabc7E=
```

To convert it to hex string :

```
$ openssl enc -base64 -d <<< QNV2GQxfFWXwmZTWmoJrSxYNLmqTUxv9g5NeQpabc7E= | od -vt x1
  0000000 40 d5 76 19 0c 5f 15 65 f0 99 94 d6 9a 82 6b 4b
  0000020 16 0d 2e 6a 93 53 1b fd 83 93 5e 42 96 9b 73 b1
```

AES-256 has 128 bit blocks, so IV is generated by the following command, it's a random 16 bytes array :

```
$ openssl rand -base64 16
  0eQbwlW32F6wbv7ca2n8bg==
```

To convert it to hex string :

```
$ openssl enc -base64 -d <<< 0eQbwlW32F6wbv7ca2n8bg== | od -vt x1
  0000000 d1 e4 1b c2 55 b7 d8 5e b0 6e fe dc 6b 69 fc 6e
```

Another way could be using pbkdf2 to derivate a Key and IV from a passkey by [Key Derivation]() technique.

To encrypt the file, you can use the following command : 

```
$ openssl enc -aes-256-cbc -K 40d576190c5f1565f09994d69a826b4b160d2e6a93531bfd83935e42969b73b1 -iv d1e41bc255b7d85eb06efedc6b69fc6e 
              -in test-data/pdf/plain_document.pdf -out test-data/pdf/openssl_ciphered_file.pdf
```

According to the OpenSSL document (https://www.openssl.org/docs/man1.1.1/man1/enc.html) :
    `All the block ciphers normally use PKCS#5 padding`

To check the encryption result : 

```
$ openssl enc -aes-256-cbc -d -K 40d576190c5f1565f09994d69a826b4b160d2e6a93531bfd83935e42969b73b1 -iv d1e41bc255b7d85eb06efedc6b69fc6e 
              -in test-data/pdf/ciphered_file.pdf -out test-data/pdf/openssl_deciphered_file.pdf
```
